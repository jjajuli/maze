from time import sleep
import tkinter as tk
from tkinter import font as tkfont
from tkinter import messagebox, filedialog
import json
import os
import random
from datetime import datetime, time
from typing import List, Tuple, Set, Dict, Any
from collections import deque


# ---------------------------------------------------------
# Helper type to represent a cell (row, column)
# ---------------------------------------------------------
Cell = Tuple[int, int]


# =========================================================
#               GAME MODE: INVISIBLE MAZE
# =========================================================
class MazeGame(tk.Tk):
    """
    Main window for the invisible maze game.

    Main features:
    - The correct path is invisible.
    - If the player tries to move to a cell that is not part of the path
      (or goes out of bounds), it counts as a HIT (invisible wall).
    - The player does NOT reset to the start when they fail; they simply do not move forward.
    - A history of attempts is kept with:
        * attempt number
        * number of hits in that attempt
        * number of steps in that attempt
        * result (Goal / Manual reset)
    - The board size n x m can be configured from the interface.
    - Mazes can be loaded from JSON files generated by the editor.
    """

    def __init__(self, rows: int = 5, cols: int = 5, cell_size: int = 36, presenter_mode=False):
        """
        Game window constructor.

        Parameters:
        - rows: number of rows on the board.
        - cols: number of columns on the board.
        - cell_size: size (in pixels) of each cell.
        """
        super().__init__()
        self.title("Invisible Maze")
        self.resizable(False, False)

        # ---------------- Board parameters ---------------- #
        # rows / cols: board dimensions in cells
        # cell_size: size of each cell in pixels
        self.rows = rows
        self.cols = cols
        self.cell_size = cell_size

        # margin: margin around the board inside the canvas
        self.margin = 12
        self.canvas_w = self.cols * self.cell_size + self.margin * 2
        self.canvas_h = self.rows * self.cell_size + self.margin * 2

        # ------------------------------------------------------
        # --- Botón 3: estado de laberinto/solución guardada ---
        self.b3_has_maze = False
        self.b3_solution_moves = []   # lista de deltas (dr, dc)
        self.b3_anim_job = None       # id del after para animación
        self._b3_step_i = 0


        # ---------------- Maze state ---------------- #
        # start: starting cell
        # goal: goal cell
        # path: ordered list of cells that make up the valid path
        # path_set: set to check in O(1) whether a cell belongs to the path
        self.start: Cell = (0, 0)
        self.goal: Cell = (self.rows - 1, self.cols - 1)
        self.path: List[Cell] = []
        self.path_set: Set[Cell] = set()

        # player: current player position
        self.player: Cell = self.start
        self.auto_play = False  # indicates if automatic movement is running (Button1)

        # loaded_maze: if a maze is loaded from a file, its definition is stored here
        self.loaded_maze: Dict[str, Any] | None = None

        # ---------------- Hit/attempt tracking ---------------- #
        # current_hits: hits in the current attempt (invisible walls)
        # total_hits: accumulated hits in the current maze
        # current_steps: number of steps (movement attempts) in the current attempt
        # attempt_index: attempt counter (1, 2, 3, ...)
        # attempts_history: list of dicts summarizing each attempt
        self.current_hits: int = 0
        self.total_hits: int = 0
        self.current_steps: int = 0
        self.attempt_index: int = 1
        self.attempts_history: List[Dict[str, Any]] = []

        # ------------------------------------------------------
        # Visual configuration
        # ------------------------------------------------------
        if presenter_mode:
            # Fullscreen
            # self.attributes("-fullscreen", True)

            # Large fonts for audience (tuples, no quotes)
            self.font_title = ("Helvetica", 30, "bold")
            self.font_normal = ("Helvetica", 26)
            self.font_small = ("Helvetica", 26)

            # Allow exiting fullscreen with ESC
            # self.bind("<Escape>", lambda e: self.attributes("-fullscreen", False))
        else:
            # Smaller fonts for personal use
            self.font_title = ("Helvetica", 12, "bold")
            self.font_normal = ("Helvetica", 12)
            self.font_small = ("Helvetica", 10)

        # ---------------- Main widgets ---------------- #
        # Canvas where the board is drawn
        self.canvas = tk.Canvas(self, width=self.canvas_w, height=self.canvas_h, bg="#111")
        self.canvas.grid(row=0, column=0, padx=10, pady=10)

        # Dictionary cell -> rectangle id in the canvas
        self.rect_by_cell: Dict[Cell, int] = {}
        self.build_grid_rects()

        # Bottom frame for main controls
        self.controls_frame = tk.Frame(self)
        self.controls_frame.grid(row=1, column=0, sticky="w", padx=10, pady=(0, 10))

        # Checkbox to show/hide the path visually
        self.show_path_var = tk.BooleanVar(value=False)
        self.show_path_cb = tk.Checkbutton(
            self.controls_frame,
            text="Show path",
            variable=self.show_path_var,
            command=self.render,
            font=self.font_normal
        )
        self.show_path_cb.grid(row=0, column=0, sticky="w")

        # Button to generate a new random maze
        self.reset_btn = tk.Button(self.controls_frame, text="New random", command=self.new_random_maze, font=self.font_normal)
        self.reset_btn.grid(row=0, column=1, sticky="w", padx=(5, 0))

        # Button to start a new attempt while keeping the same maze
        self.retry_btn = tk.Button(self.controls_frame, text="Try again", command=self.on_retry_clicked, font=self.font_normal)
        self.retry_btn.grid(row=0, column=2, sticky="w", padx=(5, 0))

        # Button to load a maze from JSON (created by the editor)
        self.load_btn = tk.Button(self.controls_frame, text="Load maze", command=self.load_maze_from_file, font=self.font_normal)
        self.load_btn.grid(row=0, column=3, sticky="w", padx=(5, 0))

        # Label showing attempt number and current steps
        self.attempt_info_var = tk.StringVar(value="Attempt 1 | Steps: 0")
        self.attempt_info_lbl = tk.Label(self.controls_frame, textvariable=self.attempt_info_var, font=self.font_title)
        self.attempt_info_lbl.grid(row=1, column=1, sticky="w", padx=(10, 0))

        # Label showing hits in the current attempt
        self.hits_var = tk.StringVar(value="Hits: 0")
        self.hits_lbl = tk.Label(self.controls_frame, textvariable=self.hits_var, font=self.font_title)
        self.hits_lbl.grid(row=1, column=2, sticky="w", padx=(10, 0))

        # ---------------- Right panel: size, history, extra buttons ---------------- #
        self.side_frame = tk.Frame(self, bd=1, relief="groove")
        self.side_frame.grid(row=0, column=1, rowspan=2, sticky="ns", padx=(0, 10), pady=10)

        # --- Board size section --- #
        size_title = tk.Label(self.side_frame, text="Board size", font=self.font_title)
        size_title.pack(anchor="w", padx=8, pady=(6, 2))

        size_frame = tk.Frame(self.side_frame)
        size_frame.pack(anchor="w", padx=8, pady=(0, 6))

        tk.Label(size_frame, text="Rows (n):", font=self.font_normal).grid(row=0, column=0, sticky="w")
        tk.Label(size_frame, text="Columns (m):", font=self.font_normal).grid(row=1, column=0, sticky="w")

        # rows_var / cols_var: variables bound to the size Spinboxes
        self.rows_var = tk.IntVar(value=self.rows)
        self.cols_var = tk.IntVar(value=self.cols)

        self.rows_spin = tk.Spinbox(size_frame, from_=2, to=50, width=5, textvariable=self.rows_var, font=self.font_normal)
        self.rows_spin.grid(row=0, column=1, sticky="w", padx=(4, 0))

        self.cols_spin = tk.Spinbox(size_frame, from_=2, to=50, width=5, textvariable=self.cols_var, font=self.font_normal)
        self.cols_spin.grid(row=1, column=1, sticky="w", padx=(4, 0))

        self.apply_size_btn = tk.Button(size_frame, text="Apply size", command=self.on_apply_board_size, font=self.font_normal)
        self.apply_size_btn.grid(row=2, column=0, columnspan=2, pady=(4, 0), sticky="we")

        # --- Attempts history section --- #
        history_title = tk.Label(self.side_frame, text="Attempts history", font=self.font_title)
        history_title.pack(anchor="w", padx=8, pady=(8, 2))

        # Listbox showing a summary of each attempt with a scrollbar and auto-scroll
        self.history_scrollbar = tk.Scrollbar(self.side_frame, orient="vertical")
        self.history_scrollbar.pack(side="right", fill="y", padx=(0, 8), pady=(0, 6))
        self.history_listbox = tk.Listbox(self.side_frame, width=45, height=14, yscrollcommand=self.history_scrollbar.set, font=self.font_small)
        self.history_listbox.pack(anchor="w", padx=8, pady=(0, 6))
        self.history_scrollbar.config(command=self.history_listbox.yview)

        # Button to clear history without changing the maze
        self.clear_history_btn = tk.Button(self.side_frame, text="Clear history", command=self.clear_history, font=self.font_normal)
        self.clear_history_btn.pack(anchor="w", padx=8, pady=(0, 8))

        # --- Extra buttons (Button1 ... Button6) --- #
        #extra_title = tk.Label(self.side_frame, text="Extra buttons", font=self.font_title)
        #extra_title.pack(anchor="w", padx=8, pady=(4, 2))

        extra_btns_frame = tk.Frame(self.side_frame)
        extra_btns_frame.pack(anchor="w", padx=8, pady=(0, 8))

        # Button1..Button6 prepared for future functionality
        self.btn1 = tk.Button(extra_btns_frame, text="Random", width=10, command=self.on_boton1, font=self.font_normal)
        self.btn2 = tk.Button(extra_btns_frame, text="Ran+Memo", width=10, command=self.on_boton2, font=self.font_normal)
        self.btn3 = tk.Button(extra_btns_frame, text="RL-Trained", width=10, command=self.on_boton3, font=self.font_normal)
        self.btn4 = tk.Button(extra_btns_frame, text="Button4", width=10, command=self.on_boton4, font=self.font_normal)
        self.btn5 = tk.Button(extra_btns_frame, text="Button5", width=10, command=self.on_boton5, font=self.font_normal)
        self.btn6 = tk.Button(extra_btns_frame, text="Button6", width=10, command=self.on_boton6, font=self.font_normal)

        # Layout in two columns (3 rows x 2 columns)
        self.btn1.grid(row=0, column=0, padx=2, pady=2, sticky="we")
        self.btn2.grid(row=0, column=1, padx=2, pady=2, sticky="we")
        self.btn3.grid(row=1, column=0, padx=2, pady=2, sticky="we")
        #self.btn4.grid(row=1, column=1, padx=2, pady=2, sticky="we")
        #self.btn5.grid(row=2, column=0, padx=2, pady=2, sticky="we")
        #self.btn6.grid(row=2, column=1, padx=2, pady=2, sticky="we")

        # ---------------- Keyboard controls ---------------- #
        # Arrow keys and WASD move the player
        self.bind_all("<Up>", lambda e: self.try_move((-1, 0)))
        self.bind_all("<Down>", lambda e: self.try_move((1, 0)))
        self.bind_all("<Left>", lambda e: self.try_move((0, -1)))
        self.bind_all("<Right>", lambda e: self.try_move((0, 1)))
        self.bind_all("w", lambda e: self.try_move((-1, 0)))
        self.bind_all("s", lambda e: self.try_move((1, 0)))
        self.bind_all("a", lambda e: self.try_move((0, -1)))
        self.bind_all("d", lambda e: self.try_move((0, 1)))

        # ---------------- Maze initialization ---------------- #
        # Generate a random maze and prepare the first attempt
        self.generate_path_random()
        self.reset_attempts_for_new_maze()
        self.render()

        self.update_idletasks()

    # -----------------------------------------------------
    # Board rendering
    # -----------------------------------------------------
    def render(self):
        show_path = self.show_path_var.get()

        # Choose color set depending on presentation mode
        if getattr(self, "presentation_colors", True):
            # ------------------ PRESENTATION MODE ------------------
            color_bg = "#ffffff"
            color_wall = "#ffffff"
            color_outline = "#555555"
            color_path = "#bbbbbb"
            color_start = "#76e6a4"
            color_goal = "#fda744"
            color_player = "#56bfdf"
            color_player_outline = "#0d3c55"
            self.canvas.config(bg=color_bg)
        else:
            # ------------------ NORMAL MODE ------------------------
            color_bg = "#111"
            color_wall = "#000"
            color_outline = "#222"
            color_path = "#2b2b2b"
            color_start = "#2ecc71"
            color_goal = "#f1c40f"
            color_player = "#3498db"
            color_player_outline = "#5faee3"
            self.canvas.config(bg=color_bg)

        for r in range(self.rows):
            for c in range(self.cols):
                cell = (r, c)
                rect = self.rect_by_cell.get(cell)
                if rect is None:
                    continue

                fill = color_wall
                outline = color_outline

                if show_path and cell in self.path_set:
                    fill = color_path

                if cell == self.start:
                    fill = color_start

                if cell == self.goal:
                    fill = color_goal

                if cell == self.player:
                    fill = color_player
                    outline = color_player_outline

                self.canvas.itemconfig(rect, fill=fill, outline=outline)

        self.canvas.update_idletasks()

    # -----------------------------------------------------
    # Grid construction (rectangles on the canvas)
    # -----------------------------------------------------
    def build_grid_rects(self):
        """
        Creates or recreates the canvas rectangles based on rows, columns, and size.

        Internal variables:
        - self.canvas_w / self.canvas_h: canvas dimensions in pixels.
        - self.rect_by_cell: dict mapping each cell (r, c) to the corresponding
          rectangle id in the canvas.
        """
        # Adjust canvas dimensions
        self.canvas_w = self.cols * self.cell_size + self.margin * 2
        self.canvas_h = self.rows * self.cell_size + self.margin * 2
        self.canvas.config(width=self.canvas_w, height=self.canvas_h)

        # Clear any previous rectangles
        self.canvas.delete("all")
        self.rect_by_cell.clear()

        # Create the grid of cells
        for r in range(self.rows):
            for c in range(self.cols):
                x0 = self.margin + c * self.cell_size
                y0 = self.margin + r * self.cell_size
                x1 = x0 + self.cell_size
                y1 = y0 + self.cell_size
                rect = self.canvas.create_rectangle(
                    x0, y0, x1, y1,
                    fill="#000",
                    outline="#222"
                )
                self.rect_by_cell[(r, c)] = rect

    # -----------------------------------------------------
    # Change board size (n * m) from the UI
    # -----------------------------------------------------
    def apply_board_size(self, rows: int, cols: int, cell_size: int | None = None):
        """
        Changes the board dimensions and rebuilds the grid.

        Parameters:
        - rows: new number of rows.
        - cols: new number of columns.
        - cell_size: optional cell size, if it should be changed too.
        """
        self.rows = int(rows)
        self.cols = int(cols)
        if cell_size is not None:
            self.cell_size = int(cell_size)

        # Reset start/goal/player positions with the new dimensions
        self.start = (0, 0)
        self.goal = (self.rows - 1, self.cols - 1)
        self.player = self.start

        # Rebuild the graphical grid
        self.build_grid_rects()

    def on_apply_board_size(self):
        """
        Reads row/column values from the right-side controls
        and applies the new size, regenerating a maze and resetting attempts.
        """
        try:
            new_rows = int(self.rows_var.get())
            new_cols = int(self.cols_var.get())
            if new_rows < 2 or new_cols < 2:
                raise ValueError
        except ValueError:
            messagebox.showerror("Invalid value", "Rows and columns must be integers greater than or equal to 2.")
            return

        # Apply the new size and generate a new path
        self.apply_board_size(new_rows, new_cols, self.cell_size)
        self.generate_path_random()
        self.reset_attempts_for_new_maze()
        self.render()

    # -----------------------------------------------------
    # Random maze generation (single path)
    # -----------------------------------------------------
    def new_random_maze(self):
        """
        Generates a new random path and forgets any loaded maze.
        Also resets attempts history for the new maze.
        """
        self.loaded_maze = None
        self.generate_path_random()
        self.reset_attempts_for_new_maze()
        self.render()
        self.b3_has_maze = False
        self.b3_solution_moves = []

    def generate_path_random(self):
        """
        Generates a valid path between start and goal using a random DFS.

        Internal variables:
        - dirs: possible moves (up, down, left, right).
        - visited: set of visited cells.
        - parent: dict to reconstruct the parent -> child path.
        """
        self.path = self._dfs_path(self.start, self.goal)
        tries = 0
        # If for some reason no path is found, try several times
        while not self.path and tries < 10:
            tries += 1
            self.path = self._dfs_path(self.start, self.goal)

        if not self.path:
            # Fallback: build an "L"-shaped path
            self.path = []
            r, c = self.start
            while c < self.goal[1]:
                self.path.append((r, c))
                c += 1
            while r < self.goal[0]:
                self.path.append((r, c))
                r += 1
            self.path.append(self.goal)

        self.path_set = set(self.path)

    def _dfs_path(self, start: Cell, goal: Cell) -> List[Cell]:
        """
        Implements a random depth-first search (DFS) to find a path.

        Parameters:
        - start: starting cell.
        - goal: target cell.

        Returns:
        - List of cells forming the path from start to goal.
        """
        dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        visited = {start}
        parent: Dict[Cell, Cell] = {}
        stack: List[Cell] = [start]

        while stack:
            cur = stack.pop()
            if cur == goal:
                break
            r, c = cur
            random.shuffle(dirs)  # shuffle directions to vary the maze
            for dr, dc in dirs:
                nr, nc = r + dr, c + dc
                nxt = (nr, nc)
                if 0 <= nr < self.rows and 0 <= nc < self.cols and nxt not in visited:
                    visited.add(nxt)
                    parent[nxt] = cur
                    stack.append(nxt)

        if goal not in parent and goal != start:
            return []

        # Reconstruct the path from goal back to start using 'parent'
        path = [goal]
        cur = goal
        while cur != start:
            cur = parent[cur]
            path.append(cur)
        path.reverse()
        return path

    # -----------------------------------------------------
    # Load mazes from a JSON file
    # -----------------------------------------------------
    def load_maze_from_file(self):
        """
        Lets the user select a JSON file with a maze and applies it.
        The format is compatible with the path editor.
        """
        filepath = filedialog.askopenfilename(
            title="Select a maze file",
            filetypes=[("JSON", "*.json"), ("All", "*.*")],
            initialdir=os.path.abspath("paths") if os.path.isdir("paths") else os.getcwd()
        )
        if not filepath:
            return

        try:
            with open(filepath, "r", encoding="utf-8") as f:
                data = json.load(f)
            self.apply_loaded_maze(data)
            messagebox.showinfo("Maze loaded", f"Maze loaded from:\n{filepath}")
        except Exception as e:
            messagebox.showerror("Error", f"Could not load file:\n{e}")

    def apply_loaded_maze(self, data: Dict[str, Any]):
        """
        Applies dimensions, start/goal, and path from a dict loaded from JSON.

        Expected keys in 'data':
        - rows, cols, cell_size: board size.
        - start, goal: pairs [row, col].
        - path: list of pairs [row, col] defining the path.
        """
        rows = int(data.get("rows", self.rows))
        cols = int(data.get("cols", self.cols))
        cell_size = int(data.get("cell_size", self.cell_size))
        start_list = data.get("start", [0, 0])
        goal_list = data.get("goal", [rows - 1, cols - 1])
        path_list = data.get("path", [])

        # Adjust board to file dimensions
        self.apply_board_size(rows, cols, cell_size)

        # Set start and goal (clamped for safety)
        sr, sc = int(start_list[0]), int(start_list[1])
        gr, gc = int(goal_list[0]), int(goal_list[1])
        sr = max(0, min(self.rows - 1, sr))
        sc = max(0, min(self.cols - 1, sc))
        gr = max(0, min(self.rows - 1, gr))
        gc = max(0, min(self.cols - 1, gc))
        self.start = (sr, sc)
        self.goal = (gr, gc)
        self.player = self.start

        # Build path cell list
        path: List[Cell] = []
        for rc in path_list:
            if isinstance(rc, list) and len(rc) == 2:
                r, c = int(rc[0]), int(rc[1])
                if 0 <= r < self.rows and 0 <= c < self.cols:
                    path.append((r, c))

        # Ensure start and goal are in the path
        if self.start not in path:
            path.insert(0, self.start)
        if self.goal not in path:
            path.append(self.goal)

        self.path = path
        self.path_set = set(self.path)

        # Save so the same maze can be reset after winning
        self.loaded_maze = {
            "rows": self.rows,
            "cols": self.cols,
            "cell_size": self.cell_size,
            "start": self.start,
            "goal": self.goal,
            "path": [list(c) for c in self.path],
        }

        # Loading a new maze resets attempts and history
        self.reset_attempts_for_new_maze()
        self.render()

    # -----------------------------------------------------
    # Movement logic with INVISIBLE WALLS
    # -----------------------------------------------------
    def try_move(self, delta: Tuple[int, int]):
        """
        Attempts to move the player according to delta (dr, dc).

        Parameters:
        - delta: tuple (dr, dc) shift in rows and columns.

        Behavior:
        - If the destination cell is out of bounds, count a hit and do not move.
        - If the destination cell is not in the valid path, count a hit and do not move.
        - If the destination cell is on the path, move the player.
        - Upon reaching the goal, the attempt ends successfully.
        """
        # Each movement key press counts as a step in the attempt
        self.current_steps += 1
        self.update_attempt_info_label()

        match delta:
            case (-1, 0):  # Up
                self.history_listbox.insert(tk.END, "UP")
                self.history_listbox.see(tk.END) 
            case (0, 1):  # Right
                self.history_listbox.insert(tk.END, "RIGHT")
                self.history_listbox.see(tk.END) 
            case (1, 0):  # Down
                self.history_listbox.insert(tk.END, "DOWN")
                self.history_listbox.see(tk.END) 
            case (0, -1):  # Left
                self.history_listbox.insert(tk.END, "LEFT")
                self.history_listbox.see(tk.END) 

        nr = self.player[0] + delta[0]
        nc = self.player[1] + delta[1]
        nxt = (nr, nc)

        # Case 1: out of bounds -> hit (external invisible wall)
        if not (0 <= nr < self.rows and 0 <= nc < self.cols):
            self.register_hit()
            # Flash current cell to indicate collision
            self.flash_cell(self.player, color="#ff0000")
            return

        # Case 2: inside board but outside path -> hit (invisible wall)
        if nxt not in self.path_set:
            self.register_hit()
            self.flash_cell(self.player, color="#ff0000")
            return

        # Case 3: valid movement on the path
        self.player = nxt
        self.render()

        # Check if the goal was reached
        if self.player == self.goal:
            # If NOT in auto mode, handle victory normally
            if not getattr(self, "auto_play", False):
                self.on_win()
                return

    def register_hit(self):
        """
        Registers a hit against an invisible wall in the current attempt.

        Effects:
        - Increments current_hits and total_hits.
        - Updates the hits label.
        """
        self.current_hits += 1
        self.total_hits += 1
        self.update_hits_label()

    def on_retry_clicked(self):
        """
        Callback for the 'Try again' button.

        Behavior:
        - Closes the current attempt (result: 'Reset').
        - Records that attempt in the history.
        - Creates a new attempt from the start with counters reset.
        """
        self.end_current_attempt(completed=False)
        self.start_new_attempt()

    def on_win(self):
        """
        Called when the player reaches the goal.

        Behavior:
        - Closes the current attempt (result: 'Goal').
        - Shows a message with the hit summary.
        - Reloads the same maze if it came from a file,
          or generates a new random one otherwise.
        - Starts a new attempt for the newly prepared maze.
        """
        # Finish current attempt as successful
        self.end_current_attempt(completed=True)

        # Summary of the attempt that just ended
        last = self.attempts_history[-1] if self.attempts_history else None
        golpes = last["golpes"] if last else self.current_hits
        pasos = last["pasos"] if last else self.current_steps

        messagebox.showinfo(
            "You made it!",
            f"You reached the goal.\n"
        )
        self.start_new_attempt()
        # Reset while keeping the same maze if it was loaded,
        # or generating a new one otherwise.
        # if self.loaded_maze is not None:
        #     self.apply_loaded_maze(self.loaded_maze)
        # else:
        #     self.new_random_maze()

    # -----------------------------------------------------
    # Attempt and history management
    # -----------------------------------------------------
    def reset_attempts_for_new_maze(self):
        """
        Prepares internal state when starting to use a new maze.

        Effects:
        - Clears attempts history.
        - Resets total hit counters.
        - Sets attempt index to 1.
        - Starts the first attempt.
        """
        self.attempts_history.clear()
        self.history_listbox.delete(0, tk.END)
        self.total_hits = 0
        self.attempt_index = 1
        self.start_new_attempt()

    def start_new_attempt(self):
        """
        Starts a new attempt from the maze's start cell.

        Effects:
        - Places the player at start.
        - Resets current_hits and current_steps.
        - Updates info labels.
        """
        self.player = self.start
        self.current_hits = 0
        self.current_steps = 0
        self.update_hits_label()
        self.update_attempt_info_label()
        self.render()

    def end_current_attempt(self, completed: bool):
        """
        Closes the current attempt and adds it to the history.

        Parameters:
        - completed: True if the attempt ends by reaching the goal,
                     False if it ends by manual reset.

        Effects:
        - Inserts a record into attempts_history.
        - Adds a descriptive line to the history Listbox.
        - Increments the attempt index for the next attempt.
        """
        resultado = "Goal" if completed else "Reset"
        record = {
            "numero": self.attempt_index,
            "golpes": self.current_hits,
            "pasos": self.current_steps,
            "resultado": resultado,
        }
        self.attempts_history.append(record)

        # Readable text shown in the history
        line = (
            f"Attempt {record['numero']}: "
            f"hits={record['golpes']}, "
            f"steps={record['pasos']}, "
            f"result={record['resultado']}"
        )
        self.history_listbox.insert(tk.END, line)
        self.history_listbox.see(tk.END) 
        self.attempt_index += 1

    def clear_history(self):
        """
        Clears the attempts history without modifying the maze or the current attempt.
        """
        self.attempts_history.clear()
        self.history_listbox.delete(0, tk.END)

    def update_hits_label(self):
        """
        Updates the text of the hits label for the current attempt.
        """
        self.hits_var.set(f"Hits: {self.current_hits}")

    def update_attempt_info_label(self):
        """
        Updates the text of the label showing attempt number and current steps.
        """
        self.attempt_info_var.set(f"Attempt {self.attempt_index} | Steps: {self.current_steps}")

    def flash_cell(self, cell: Cell, color: str = "#ff0000", flashes: int = 1, delay_ms: int = 70):
        """
        Flashes a board cell with a given color to indicate an event
        (for example, hitting an invisible wall).

        Parameters:
        - cell: cell to highlight.
        - color: temporary flash color.
        - flashes: how many times to flash.
        - delay_ms: delay in milliseconds between color changes.
        """
        rect = self.rect_by_cell.get(cell)
        if not rect:
            return
        original = self.canvas.itemcget(rect, "fill")
        for _ in range(flashes):
            self.canvas.itemconfig(rect, fill=color)
            self.canvas.update_idletasks()
            self.after(delay_ms)
            self.canvas.itemconfig(rect, fill=original)
            self.canvas.update_idletasks()
            self.after(delay_ms)

    def _b3_solve_moves_bfs(self):
        """
        Calcula una ruta desde start hasta goal usando BFS sobre self.path_set
        y devuelve la solución como lista de deltas [(dr,dc), ...].
        """
        start = self.start
        goal = self.goal

        # seguridad: start/goal deben ser transitables
        if start not in self.path_set or goal not in self.path_set:
            return []

        q = deque([start])
        prev = {start: None}

        while q:
            cur = q.popleft()
            if cur == goal:
                break

            r, c = cur
            for dr, dc in [(-1, 0), (0, 1), (1, 0), (0, -1)]:
                nxt = (r + dr, c + dc)
                if nxt in prev:
                    continue
                if nxt not in self.path_set:
                    continue
                prev[nxt] = cur
                q.append(nxt)

        if goal not in prev:
            return []

        # reconstruir lista de celdas
        cells = []
        cur = goal
        while cur is not None:
            cells.append(cur)
            cur = prev[cur]
        cells.reverse()

        # convertir celdas a movimientos (deltas)
        moves = []
        for i in range(1, len(cells)):
            r0, c0 = cells[i - 1]
            r1, c1 = cells[i]
            moves.append((r1 - r0, c1 - c0))

        return moves

    def _b3_run_solution(self):
        """
        Recorre self.b3_solution_moves usando try_move(delta) con animación.
        No crea laberinto nuevo. No bloquea la interfaz.
        """
        # Cancelar animación anterior si existía
        if self.b3_anim_job is not None:
            try:
                self.after_cancel(self.b3_anim_job)
            except Exception:
                pass
            self.b3_anim_job = None

        # Reiniciar jugador al inicio (mismo laberinto)
        self.player = self.start
        self.render()

        # Evitar que try_move llame on_win durante el autoplay
        self.auto_play = True
        self._b3_step_i = 0

        def step():
            # Terminar si ya llegó o si se acabaron pasos
            if self.player == self.goal or self._b3_step_i >= len(self.b3_solution_moves):
                self.auto_play = False
                self.b3_anim_job = None
                return

            delta = self.b3_solution_moves[self._b3_step_i]
            self._b3_step_i += 1

            # try_move ya hace historial, hits, render, etc.
            self.try_move(delta)

            # Programar siguiente paso
            self.b3_anim_job = self.after(200, step)
            # In case it reaches the goal inside try_move with additional logic
            if self.player == self.goal:
                self.auto_play = False  # disable before calling on_win
                self.on_win()

        step()


    """
    Extra Buttons Functionality (Stubs) *************************************************************************************
    Extra Buttons Functionality (Stubs) *************************************************************************************
    Extra Buttons Functionality (Stubs) *************************************************************************************
    """
    # -----------------------------------------------------
    # Extra buttons (Button1 ... Button6) - stubs
    # -----------------------------------------------------
    def on_boton1(self):
        """
        Automatic execution of random moves until reaching the goal.
        """
        self.auto_play = True
        try:
            while True:
                movement = random.randint(0, 3)
                match movement:
                    case 0:  # Up
                        self.try_move((-1, 0))
                    case 1:  # Right
                        self.try_move((0, 1))
                    case 2:  # Down
                        self.try_move((1, 0))
                    case 3:  # Left
                        self.try_move((0, -1))

                self.history_listbox.see(tk.END)
                self.update()
                self.after(200)

                # Check if it reached the goal to exit the loop
                if self.player == self.goal:
                    # Now it can run the victory logic
                    self.auto_play = False  # disable before calling on_win
                    self.on_win()
                    break
        finally:
            # Ensure the flag is cleared even if an error occurs
            self.auto_play = False

    def on_boton2(self):
        """
        Strategy:
        - enabled_moves = [0, 1, 2, 3] (UP, RIGHT, DOWN, LEFT).
        - At each step, choose a random move from enabled_moves.
        - If the move is invalid (hit a wall):
            -> remove that move from enabled_moves (for that cell).
        - If the move is valid:
            -> rebuild enabled_moves with all directions
               except the opposite of the move just used.
        """
        import random

        # 0: UP, 1: RIGHT, 2: DOWN, 3: LEFT
        enabled_moves = [0, 1, 2, 3]

        move_to_delta = {
            0: (-1, 0),  # UP
            1: (0, 1),   # RIGHT
            2: (1, 0),   # DOWN
            3: (0, -1),  # LEFT
        }

        move_to_name = {
            0: "UP",
            1: "RIGHT",
            2: "DOWN",
            3: "LEFT",
        }

        # Opposite movement: 0 <-> 2, 1 <-> 3
        opposite = {
            0: 2,
            1: 3,
            2: 0,
            3: 1,
        }

        # Main loop: stops if no more possible moves
        # or if the goal is reached.
        self.auto_play = True
        try:
            while enabled_moves and self.player != self.goal:
                move = random.choice(enabled_moves)
                delta = move_to_delta[move]

                old_pos = self.player
                self.try_move(delta)
                new_pos = self.player

                # Log move in history
                self.history_listbox.insert(tk.END, move_to_name[move])
                self.history_listbox.see(tk.END)

                # Animation
                self.update()
                self.after(200)

                moved = (new_pos != old_pos)

                if moved:
                    # Valid move:
                    # from the new position, reopen EVERYTHING except the opposite
                    opp = opposite[move]
                    enabled_moves = [m for m in [0, 1, 2, 3] if m != opp]
                else:
                    # Invalid move (hit):
                    # remove ONLY this direction, keep trying the others
                    enabled_moves = [m for m in enabled_moves if m != move]

                # In case it reaches the goal inside try_move with additional logic
                if self.player == self.goal:
                    self.auto_play = False  # disable before calling on_win
                    self.on_win()
                    break
        finally:
            # Ensure the flag is cleared even if an error occurs
            self.auto_play = False
    def on_boton3(self):
        """
        Botón 3:
        - Si aún no hay laberinto guardado por este botón:
            crea laberinto nuevo, calcula y guarda solución, y la recorre.
        - Si ya existe:
            no cambia laberinto, solo recorre la solución guardada.
        """
        if not self.b3_has_maze:
            # 1) crear nuevo laberinto
            self.new_random_maze()

            # 2) calcular solución y guardarla
            self.b3_solution_moves = self._b3_solve_moves_bfs()

            # si por alguna razón no hay ruta, no activar el modo guardado
            if not self.b3_solution_moves:
                self.b3_has_maze = False
                return

            self.b3_has_maze = True



        # 3) recorrer solución guardada (sin cambiar laberinto)
        self._b3_run_solution()

    def on_boton4(self):
        """
        Reserved space for future functionality associated with Button4.
        """
        messagebox.showinfo("Button4", "Reserved space for a future function (Button4).")

    def on_boton5(self):
        """
        Reserved space for future functionality associated with Button5.
        """
        messagebox.showinfo("Button5", "Reserved space for a future function (Button5).")

    def on_boton6(self):
        """
        Reserved space for future functionality associated with Button6.
        """
        messagebox.showinfo("Button6", "Reserved space for a future function (Button6).")


# =========================================================
#           EDITOR MODE: JSON PATH CREATION
# =========================================================
class PathEditorGame(tk.Tk):
    """
    "Editor" version: the user defines the path by moving.

    Functionality:
    - The traveled trail remains painted in gray.
    - Start (green) and Goal (yellow) are always visible.
    - Upon reaching the goal, the path can be saved to a JSON.
    - Generated files are compatible with MazeGame.load_maze_from_file.
    """

    def __init__(self, rows: int = 7, cols: int = 7, cell_size: int = 36):
        super().__init__()
        self.title("Path Editor - Invisible Maze")
        self.resizable(False, False)

        # --- Grid configuration ---
        self.rows = rows
        self.cols = cols
        self.cell_size = cell_size
        self.margin = 12
        self.canvas_w = self.cols * self.cell_size + self.margin * 2
        self.canvas_h = self.rows * self.cell_size + self.margin * 2

        # --- Editor state ---
        self.start: Cell = (0, 0)
        self.goal: Cell = (self.rows - 1, self.cols - 1)
        self.player: Cell = self.start

        # trail: sequence of cells visited by the player
        self.trail: List[Cell] = [self.start]
        self.trail_set: Set[Cell] = {self.start}

        # --- Main UI ---
        self.canvas = tk.Canvas(self, width=self.canvas_w, height=self.canvas_h, bg="#111")
        self.canvas.grid(row=0, column=0, columnspan=5, padx=10, pady=10)

        self.new_btn = tk.Button(self, text="New (clear)", command=self.reset_board)
        self.new_btn.grid(row=1, column=0, sticky="w", padx=(12, 0))

        self.restart_btn = tk.Button(self, text="Back to start", command=self.restart_player)
        self.restart_btn.grid(row=1, column=1, sticky="w")

        self.save_btn = tk.Button(self, text="Save path", command=self.save_path)
        self.save_btn.grid(row=1, column=2, sticky="w")

        self.load_btn = tk.Button(self, text="Load and draw path", command=self.load_and_draw_path)
        self.load_btn.grid(row=1, column=3, sticky="w")

        self.info_lbl = tk.Label(self, text="Move with arrows/WASD. Reach the goal to save.")
        self.info_lbl.grid(row=1, column=4, sticky="e", padx=(0, 12))

        # Rectangles per cell
        self.rect_by_cell: Dict[Cell, int] = {}
        for r in range(self.rows):
            for c in range(self.cols):
                x0 = self.margin + c * self.cell_size
                y0 = self.margin + r * self.cell_size
                x1 = x0 + self.cell_size
                y1 = y0 + self.cell_size
                rect = self.canvas.create_rectangle(x0, y0, x1, y1, fill="#000", outline="#222")
                self.rect_by_cell[(r, c)] = rect

        # Keyboard controls (arrows + WASD)
        self.bind_all("<Up>",   lambda e: self.try_move((-1, 0)))
        self.bind_all("<Down>", lambda e: self.try_move((1, 0)))
        self.bind_all("<Left>", lambda e: self.try_move((0, -1)))
        self.bind_all("<Right>", lambda e: self.try_move((0, 1)))
        self.bind_all("w", lambda e: self.try_move((-1, 0)))
        self.bind_all("s", lambda e: self.try_move((1, 0)))
        self.bind_all("a", lambda e: self.try_move((0, -1)))
        self.bind_all("d", lambda e: self.try_move((0, 1)))

        self.render()

    # ----------------- Movement in the editor ----------------- #
    '''
    def try_move(self, delta: Tuple[int, int]):
        """
        Moves the player within board limits and records the trail.

        Parameters:
        - delta: tuple (dr, dc) with the displacement.
        """
        nr = self.player[0] + delta[0]
        nc = self.player[1] + delta[1]
        if not (0 <= nr < self.rows and 0 <= nc < self.cols):
            # Out of the board: ignore movement
            return
        nxt = (nr, nc)
        self.player = nxt

        # Record the cell in the trail (allowing repeats in the sequence)
        self.trail.append(nxt)
        self.trail_set.add(nxt)
        self.render()

        if self.player == self.goal:
            self.on_reach_goal()
    '''
    def on_reach_goal(self):
        """
        Asks whether to save the path when reaching the goal.
        """
        ans = messagebox.askyesno("Goal reached", "Do you want to save this path with a timestamp?")
        if ans:
            self.save_path()

    # ----------------- Save / Load ----------------- #
    def build_path_payload(self) -> Dict[str, Any]:
        """
        Builds the dictionary that will be saved as JSON.

        Keys:
        - rows, cols, cell_size
        - start, goal
        - path: list of [row, col] visited (full traversal)
        - created_at: ISO-8601 timestamp.
        """
        return {
            "rows": self.rows,
            "cols": self.cols,
            "cell_size": self.cell_size,
            "start": [self.start[0], self.start[1]],
            "goal": [self.goal[0], self.goal[1]],
            "path": [[r, c] for (r, c) in self.trail],
            "created_at": datetime.utcnow().isoformat(timespec="seconds") + "Z",
        }

    def save_path(self):
        """
        Saves the current path to a JSON file inside ./paths.
        """
        os.makedirs("paths", exist_ok=True)
        payload = self.build_path_payload()
        timestamp = datetime.utcnow().strftime("%Y%m%d_%H%M%S")
        default_name = f"path_{timestamp}.json"
        filepath = filedialog.asksaveasfilename(
            title="Save path",
            defaultextension=".json",
            initialdir=os.path.abspath("paths"),
            initialfile=default_name,
            filetypes=[("JSON", "*.json"), ("All", "*.*")]
        )
        if not filepath:
            return
        try:
            with open(filepath, "w", encoding="utf-8") as f:
                json.dump(payload, f, indent=2, ensure_ascii=False)
            messagebox.showinfo("Saved", f"Path saved to:\n{filepath}")
        except Exception as e:
            messagebox.showerror("Error", f"Could not save file:\n{e}")

    def load_and_draw_path(self):
        """
        Loads a JSON file with a path and draws it on the current board.
        """
        filepath = filedialog.askopenfilename(
            title="Load path",
            filetypes=[("JSON", "*.json"), ("All", "*.*")],
            initialdir=os.path.abspath("paths") if os.path.isdir("paths") else os.getcwd()
        )
        if not filepath:
            return
        try:
            with open(filepath, "r", encoding="utf-8") as f:
                data = json.load(f)
        except Exception as e:
            messagebox.showerror("Error", f"Could not read file:\n{e}")
            return

        # Adjust dimensions if the file has different rows/cols
        rows = int(data.get("rows", self.rows))
        cols = int(data.get("cols", self.cols))
        cell_size = int(data.get("cell_size", self.cell_size))

        self.rows = rows
        self.cols = cols
        self.cell_size = cell_size
        self.canvas_w = self.cols * self.cell_size + self.margin * 2
        self.canvas_h = self.rows * self.cell_size + self.margin * 2
        self.canvas.config(width=self.canvas_w, height=self.canvas_h)

        # Rebuild the grid
        self.canvas.delete("all")
        self.rect_by_cell.clear()
        for r in range(self.rows):
            for c in range(self.cols):
                x0 = self.margin + c * self.cell_size
                y0 = self.margin + r * self.cell_size
                x1 = x0 + self.cell_size
                y1 = y0 + self.cell_size
                rect = self.canvas.create_rectangle(x0, y0, x1, y1, fill="#000", outline="#222")
                self.rect_by_cell[(r, c)] = rect

        # Apply start, goal, and trail
        start_list = data.get("start", [0, 0])
        goal_list = data.get("goal", [self.rows - 1, self.cols - 1])
        path_list = data.get("path", [])

        self.start = (int(start_list[0]), int(start_list[1]))
        self.goal = (int(goal_list[0]), int(goal_list[1]))
        self.player = self.start

        self.trail = []
        self.trail_set = set()
        for rc in path_list:
            if isinstance(rc, list) and len(rc) == 2:
                r, c = int(rc[0]), int(rc[1])
                if 0 <= r < self.rows and 0 <= c < self.cols:
                    cell = (r, c)
                    self.trail.append(cell)
                    self.trail_set.add(cell)

        if not self.trail:
            self.trail = [self.start]
            self.trail_set = {self.start}

        self.render()
        messagebox.showinfo("Path loaded", f"Path loaded from:\n{filepath}")

    # ----------------- Reset and rendering ----------------- #
    def reset_board(self):
        """
        Clears the board and resets the traversal to the initial state.
        """
        self.player = self.start
        self.trail = [self.start]
        self.trail_set = {self.start}
        self.render()

    def restart_player(self):
        """
        Moves the player to the start cell without clearing the trail.
        """
        self.player = self.start
        self.render()


# =========================================================
#                        ENTRY POINT
# =========================================================
def main():
    """
    Main entry point.

    By default, it launches the invisible maze game (MazeGame).
    To launch the path editor, comment out the MazeGame part
    and uncomment the PathEditorGame part.
    """
    # Game mode (user requests applied here):
    presenter = 1

    if presenter == 0:
        app = MazeGame(rows=5, cols=5, cell_size=40, presenter_mode=False)
        app.mainloop()
    else:
        app = MazeGame(rows=4, cols=5, cell_size=160, presenter_mode=True)
        app.mainloop()

    # Editor mode (optional, if you want to run the editor separately):
    # editor = PathEditorGame(rows=7, cols=7, cell_size=36)
    # editor.mainloop()


if __name__ == "__main__":
    main()
